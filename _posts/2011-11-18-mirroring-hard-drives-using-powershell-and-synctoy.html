---
layout: post
name: mirroring-hard-drives-using-powershell-and-synctoy
title: Mirroring Hard drives Using PowerShell and SyncToy
time: 2011-11-18 09:24:00.001000000 -08:00
tags:
- ".NET"
- VHD
- Virtualization
- SyncToy
- PowerShell
- SQL Server
- Backup
---
<p align="justify"><img style="display: inline; float: right" align="right" src="https://sn2files.storage.live.com/y1pEqScU3Qzm04LrZAfaxrVuyoZ5-bVd236pu-9bPHmIIU-XF6G4isOlmp7gE5PHZnQfi-4uKO9Y9s/PowerShellLogo.jpg?psid=1" width="112" height="112"><img style="display: inline; float: right" align="right" src="https://sn2files.storage.live.com/y1pcyUQd4CpJG44gFqyyO9-I9fFQC-Ru43151DTeqlrOZPHZ2GRZLbjiKbNPa2Jzb5HpXU0yTR9Q58/SyncToyLogo.jpg?psid=1" width="109" height="109">My main protection against hard drive failure for a long time has been <a href="http://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_1" target="_blank">RAID 1</a>. I would get two identical hard drives and RAID them so that everything I do on the first drive would be replicated on the second. One time, this actually saved me from a hard drive failure with almost zero down time. </p> <p align="justify">I can say that this has worked out very well for a long time until one day I made a stupid mistake and accidently chose the wrong drive when installing Windows. I wiped out the data drive and sure enough RAID has mirrored everything I did. It was 4 days of crying, recovering data with <a href="http://diskdigger.org/" target="_blank">DiskDigger</a>, banging my head on the desk, recovering data, more crying, and so on. Since then, I dropped the RAID 1 on all my hard drives and switched to using SyncToy to mirror identical disks once a day.</p> <p align="justify">SyncToy is very simple to use and you can <a href="http://www.pchell.com/support/synctoy.shtml" target="_blank">use it with Windows Task Scheduler</a> to sync the drives at night. However, I ran into two main problems: Copying SQL Server database files, and Copying mounted VHD files. These files won’t get copied if they’re in use. To solve this problem, I need to stop the SQL Server service, and un-mount the VHD file before mirroring the drives. To do that and after <a href="http://www.amreldib.com/2011/11/powershell-study-notes.html" target="_blank">learning all about it</a>, I’ll be using PowerShell.</p> <h3>Running PowerShell Scripts</h3> <p align="justify">The first thing to try out is running PowerShell scripts in Windows. If you’re running Windows 7 like I’m, you could run into the issue of restricted execution policy. If you try to run a PowerShell script, any script, you’ll find this error message:</p> <blockquote><pre><em><strong>File C:\test.ps1 cannot be loaded because the execution of scripts is disabled on this system. </strong><br><strong>Please see "get-help about_signing" for more details.</strong></em></pre></blockquote><br /><p align="justify">This is caused by Windows limiting the ability to run PowerShell scripts by default. You can get the status of the execution policy using the PowerShell cmdlet <strong><em>Get-ExecutionPolicy</em></strong></p><br /><blockquote><br /><p><em><font color="#0000ff" face="Courier New">Get-ExecutionPolicy</font></em></p></blockquote><br /><p align="justify">To change the status of the execution policy use the <strong><em>Set-ExecutionPolicy</em></strong> cmdlet. Here, I’m switching to “Unrestricted”:</p><br /><blockquote><br /><p><em><font face="Courier New"><font color="#0000ff">Set-ExecutionPolicy</font> <font color="#0000a0">–ExecutionPolicy</font> <font color="#9b00d3">Unrestricted</font></font></em></p></blockquote><br /><p align="justify">Changing the execution policy is a one-time thing, you won’t have to worry about it again. Now, your Windows 7 is ready to run PowerShell scripts. You can read all about execution policy and running PowerShell scripts on Windows in this <a href="http://technet.microsoft.com/en-us/library/ee176949.aspx" target="_blank">TechNet article</a>.</p><br /><h3>Running PowerShell Scripts using Task Scheduler</h3><br /><p align="justify">The Task Scheduler will be responsible for running the script. It can’t run it directly, we’ll have to run PowerShell.exe and pass the script as an argument. It’s like running a PowerShell script from the command line. To do that we enter the PowerShell.exe path followed by <strong>“&amp;</strong> then the path to the script surrounded by single or double quotes (<a href="http://www.leeholmes.com/blog/2006/05/05/running-powershell-scripts-from-cmd-exe/" target="_blank">Source</a>). This helps with running scripts that have space in their path. Here’s an example:</p><br /><blockquote><br /><p><em><font face="Courier New"><strong>“C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe” “&amp; 'D:\Folder Name\Our Script.ps1'</strong></font></em></p></blockquote><br /><h3>Copying Database Files</h3><br /><p align="justify">Before we start writing the script, we’ll have to test copying the database file. I stopped the SQL service using the Services management console and tried to copy the file but it failed. Database files by default are not owned by your Windows user account. You have to take ownership of the files (the MDF file and the Log file) and grant your Windows account sufficient permission to be able to copy the files. You can use the Properties dialog to take ownership of the files. I do that and now I can copy the files.</p><br /><p align="justify">I can write all the commands in the PowerShell script directly, but I would rather break down the script into reusable functions. To prepare to copy the database files, I have 3 functions; check the status of the SQL service, stop the service and start it. I would like to maintain the status of my SQL service as it is after the mirroring is complete. I want to stop the service and start it again only if it was actually running.</p><br /><p align="justify">Checking the service status, stopping it, and starting it is the same for all services and is not related to SQL Server. You can read all about it <a href="http://www.computerperformance.co.uk/powershell/powershell_service_start.htm" target="_blank">here</a>. We can simply use the commands <strong><em>Get-Service</em></strong>, <strong><em>Stop-Service</em></strong> and <strong><em>Start-Service</em></strong>.</p><br /><p align="justify">I’m writing the functions in a bit of a generic way so that I can use them later in other scripts without having to change their content (only their name have to change). For example, I’m passing the name of the service. Here’s the <strong><em>Get-SqlServiceStatus</em></strong> function as an example:</p><br /><blockquote><br /><p><em><font face="Courier New"><a href="https://sn2files.storage.live.com/y1px6JqF-PvGPZErGVqqnJG7MYACI6XJcxAoyxwoi3mt8qEYJTI0Jj88fmKP-ZVjJ1bCJR38-VYq0A/SqlServicePropertiesWindow.jpg?psid=1" target="_blank"><img style="display: inline; float: right" title="" alt="Properties Window of SQL Service" align="right" src="https://sn2files.storage.live.com/y1px6JqF-PvGPZErGVqqnJG7MYACI6XJcxAoyxwoi3mt8qEYJTI0Jj88fmKP-ZVjJ1bCJR38-VYq0A/SqlServicePropertiesWindow.jpg?psid=1" width="250" height="281"></a><strong><font color="#0000a0">function</font> <font color="#9b00d3">Get-SqlServiceStatus</font> (<font color="#ff0000">$serviceName</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#008000"># Get a reference to the service</font><br>&nbsp;&nbsp;&nbsp; <font color="#ff0000">$sqlService</font> = <font color="#0000ff">Get-Service</font> <font color="#ff0000">$serviceName</font></strong></font></em></p><br /><p><em><font face="Courier New"><strong>&nbsp;&nbsp;&nbsp; <font color="#008000"># Return the service status</font><br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">return</font> <font color="#ff0000">$sqlService</font>.status<br>}</strong></font></em></p></blockquote><br /><p align="justify">All I need now is the name of the SQL service on my computer. To get the name of the service, navigate to the service properties dialog and pick the name of the service (not the display name). Make sure to use PowerShell escape characters to enter the name correctly. For example: “<strong>MSSQL$SQLEXPRESS</strong>” have a dollar sign ($), so I have to add a backtick before the dollar sign to make PowerShell parse the name correctly “<strong>MSSQL`$SQLEXPRESS</strong>”.</p><br /><p align="justify">&nbsp;</p><br /><h3>Mounting VHDs</h3><br /><p align="justify">I think that the common way to mount a VHD in PowerShell is using <a href="http://en.wikipedia.org/wiki/Windows_Management_Instrumentation" target="_blank">WMI</a> (Windows Management Instrumentation). A quick search online will confirm this. However, WMI is not available for Windows 7, it’s for Windows Server. We can’t mount the VHD file using WMI because the namespace “Root\Virtualization” is <a href="http://social.technet.microsoft.com/Forums/en-US/winserverpowershell/thread/a08ad18f-4b6a-46a0-bd1f-274fbbc5b737" target="_blank">not available on Windows 7</a>. This namespace include the class that could be used to mount the VHD file. If you’re running Windows Server and can use WMI, here’s a <a href="http://blogs.msdn.com/b/virtual_pc_guy/archive/2008/02/01/mounting-a-virtual-hard-disk-with-hyper-v.aspx" target="_blank">description of how to mount virtual hard drives with HyperV and WMI</a>.</p><br /><p align="justify">Aside from using WMI, normally we’d mount a VHD using the <a href="http://www.windows7news.com/2010/01/14/how-to-automatically-attach-vhd-images-in-windows-7/" target="_blank">DiskPart command</a>. To do that, create a file and name it AttachMyVHD.s for example and add this to it:</p><br /><blockquote><br /><p><code><em><strong>select vdisk file=c:\MyVHD.vhd<br>attach vdisk</strong></em></code></p></blockquote><br /><p>Then create a Windows command (.cmd) file that call the diskpart command and pass this file to it.</p><br /><blockquote><br /><p><code><em><strong>DiskPart -s "c:\AttachMyVHD.s"</strong></em></code></p></blockquote><br /><p>In the S file, we’re selecting the VHD by specifying its location, then attaching it. In the Windows command file, we’re passing the S file to the DiskPart command.</p><br /><p>In PowerShell, we’ll just execute the Windows command file. This <strong>Mount-Codebox</strong> function declares a variable with the location of the Windows command file. Codebox is the name of the VHD file I’m using.</p><br /><blockquote><br /><p><em><font face="Courier New"><strong><font color="#0000a0">function</font> <font color="#9b00d3">Mount-Codebox</font><br>{<br>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#ff0000">$scriptFile</font> = </strong><strong><font color="#c0504d">“D:\VBox\HardDrives\AttachVHD.cmd”<br></font>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#a5a5a5">&amp; </font><font color="#ff0000">$scriptFile</font><br>}</strong></font></em></p></blockquote><br /><p>To unmount a VHD, you can do the same thing, except in the S file, use <strong><em>detach vdisk</em></strong> instead of <strong><em>attach vdisk</em></strong>.</p><br /><p align="justify">Before we unmount the VHD and re-mount it after the mirroring, we need to check if it’s already mounted. We don’t want our script to change an existing status, we want it to maintain it. If the VHD is not already mounted, don’t try to unmount, then re-mount it at the end. Just skip this step altogether.</p><br /><p align="justify">To check if the VHD is already mounted, we’ll just check if the drive it creates exists or not. To check if a drive exists, we’ll use the <strong><em><a href="http://powershell.com/cs/media/p/202.aspx" target="_blank">Exists-Drive function</a></em></strong>. </p><br /><blockquote><br /><p><font face="Courier New"><em><strong><font color="#0000a0">function</font> <font color="#9b00d3">Exists-Drive</font> (<font color="#ff0000">$driveletter</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#ff0000">$drive</font> = <font color="#444444">New-Object</font> <font color="#9b00d3">System.IO.DriveInfo</font>(<font color="#ff0000">$driveletter</font>)<br>&nbsp;&nbsp;&nbsp; <font color="#ff0000">$drive</font>.DriveType <font color="#a5a5a5">-ne</font> <font color="#c0504d">'NoRootDirectory'</font>&nbsp;&nbsp; <br>}</strong></em></font></p></blockquote><br /><h3>Run SyncToy</h3><br /><p>To run SyncToy from PowerShell, we’ll use the same way we called the Windows command file above; using the <strong><em>&amp;</em></strong> symbol to execute the SyncToy EXE file. We’ll call the SyncToyCmd.exe file which is the command line equivalent of the application so we can pass the name of the backup plan as an argument. If you use the command line to call SyncToyCmd, it’ll look like this:</p><br /><blockquote><br /><p><strong><em><font face="Courier New">SyncToyCmd –R “MyBackupPlan”</font></em></strong></p></blockquote><br /><p>We’ll create the <strong><em>Run-SyncToy</em></strong> function with the backup plan name as an input so we can call it multiple times for different plans.</p><br /><blockquote><br /><p><strong><em><font face="Courier New"><font color="#0000a0">function</font> <font color="#9b00d3">Run-SyncToy</font> (<font color="#ff0000">$backupPlan</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#ff0000">$Exe</font> = <font color="#c0504d">"C:\Program Files\SyncToy 2.1\SyncToyCmd.exe"</font><br>&nbsp;&nbsp;&nbsp; &amp; <font color="#ff0000">$Exe</font> <font color="#0000a0">-R</font> <font color="#ff0000">$backupPlan</font><br>}</font></em></strong></p></blockquote><br /><h3>Write PowerShell Output to File</h3><br /><p align="justify">Logically, I’m running this script overnight and I would like to understand what happened while I’m away, so we’ll write the output of the script to a log file named with the date of when the script ran.</p><br /><p align="justify">To write the output of any PowerShell command or function to file, use the <strong><em>Out-File</em></strong> cmdlet. This <a href="http://technet.microsoft.com/en-us/library/ee176924.aspx" target="_blank">TechNet page</a> explains how to use it. Example:</p><br /><blockquote><br /><p align="justify"><strong><em><font face="Courier New"><font color="#0000ff">Get-ChildItem</font> | <font color="#0000ff">out-file</font> <font color="#c0504d">"D:\MyOutputFile.txt"</font> <font color="#0000a0">-Append -Force</font> </font></em></strong></p></blockquote><br /><p align="justify">This line write the output of the <strong><em>Get-ChildItem</em></strong> cmdlet to the text file named <strong><em>MyOutputFile.txt</em></strong> under the D drive. Notice the use of the two arguments –<strong><em>Append</em></strong>&nbsp; (which appends to the file if it already exists) and –<strong><em>Force</em></strong> (which creates the file if it doesn’t exist). </p><br /><p>We’ll need to stamp the file name with time of when the script ran, to do that we’ll use the <strong><em>Get-Date</em></strong> cmdlet and the argument –<strong><em>Format</em></strong>. Example:</p><br /><blockquote><br /><p><em><strong><font face="Courier New"><font color="#0000ff">Get-Date</font> <font color="#0000a0">-format</font> <font color="#c0504d">"yyyy-MM-dd HH-mm-ss"</font></font></strong></em></p></blockquote><br /><h3>Putting It All Together</h3><br /><p>You can notice that all the work above just creates functions to be used in the main body of the script. Here’s where we put it all together.</p><br /><blockquote><br /><p><em><strong><font face="Courier New"><font color="#0000ff">Clear-Host</font><br><font color="#008000"># Decleare variable to hold the service name<br></font><font color="#ff0000">$serviceName</font> = <font color="#c0504d">"MSSQL`$SQLEXPRESS"</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Where the log file will be stored</font><br><font color="#ff0000">$logHome</font> = <font color="#c0504d">"D:\Amr\Backup\BackupLogs\"</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Get timestamp</font><br><font color="#ff0000">$timeStamp</font> = <font color="#0000ff">Get-Date</font> <font color="#0000a0">-Format</font> <font color="#c0504d">"yyyy-MM-dd HH-mm-ss"</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Generate name of log file</font><br><font color="#ff0000">$logFile</font> = <font color="#ff0000">$logHome</font> + <font color="#c0504d">"Backup Log "</font> + <font color="#ff0000">$timeStamp</font> + <font color="#c0504d">".txt"</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Write a starting message</font><br><font color="#c0504d">"Starting backup at $timestamp"</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Stop the SQL service if it's running<br></font><font color="#ff0000">$serviceStatus</font> = <font color="#0000ff">Get-SqlServiceStatus</font> (<font color="#ff0000">$serviceName</font>)<br><font color="#c0504d">"Service $serviceName is $serviceStatus."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#0000a0">if</font> (<font color="#ff0000">$serviceStatus</font> <font color="#a5a5a5">-eq</font> <font color="#c0504d">"Running"</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#c0504d">"SQL service is running, stopping it..."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">Stop-SqlService</font> (<font color="#ff0000">$serviceName</font>) <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>}</font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Unmount Codebox if it was already mounted</font><br><font color="#ff0000">$CodeboxMounted</font> = <font color="#0000ff">Exists-Drive</font> <font color="#c0504d">"M:"<br></font><font color="#0000a0">if</font> (<font color="#ff0000">$CodeboxMounted</font> <font color="#a5a5a5">-eq</font> <font color="#c0504d">"True"</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#c0504d">"Codebox is mounted. Unmounting Codebox..."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#008000">&nbsp;&nbsp;&nbsp; # Unmount Codebox</font><br><font color="#0000ff">&nbsp;&nbsp;&nbsp; Unmount-Codebox</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#c0504d">&nbsp;&nbsp;&nbsp; "Codebox is not mounted now."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>}<br><font color="#0000a0">else</font><br>{<br>&nbsp;&nbsp;&nbsp; <font color="#c0504d">"Codebox is not mounted"</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>}</font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Run sync toy</font><br><font color="#0000ff">Run-SyncToy</font> (<font color="#c0504d">"TestBackup"</font>) <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font></font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Mount Codebox if it was already mounted</font><br><font color="#0000a0">if</font> (<font color="#ff0000">$CodeboxMounted</font> <font color="#a5a5a5">-eq</font> <font color="#c0504d">"True"</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#c0504d">"Mounting Codebox..."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#008000">&nbsp;&nbsp;&nbsp; # Mount Codebox</font><br><font color="#0000ff">&nbsp;&nbsp;&nbsp; Mount-Codebox</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#c0504d">&nbsp;&nbsp;&nbsp; "Codebox is mounted now."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>}</font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Run the SQL service if it's stopped</font><br><font color="#ff0000">$serviceStatus</font> = <font color="#0000ff">Get-SqlServiceStatus</font> (<font color="#ff0000">$serviceName</font>)<br><font color="#c0504d">"Service $serviceName is $serviceStatus."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#0000a0">if</font> (<font color="#ff0000">$serviceStatus</font> <font color="#a5a5a5">-eq</font> <font color="#c0504d">"Stopped"</font>)<br>{<br>&nbsp;&nbsp;&nbsp; <font color="#c0504d">"Starting SQL service..."</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br><font color="#0000ff">&nbsp;&nbsp;&nbsp; Start-SqlService</font> (<font color="#ff0000">$serviceName</font>) <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font><br>}</font></strong></em></p><br /><p><em><strong><font face="Courier New"><font color="#008000"># Write end message</font><br><font color="#ff0000">$finishTime</font> = <font color="#0000ff">Get-Date</font> <font color="#0000a0">-Format</font> <font color="#c0504d">"yyyy-MM-dd HH-mm-ss"</font><br><font color="#c0504d">"Backup script finished at $finishTime"</font> <font color="#a5a5a5">|</font> <font color="#0000ff">out-file</font> <font color="#ff0000">$logFile</font> <font color="#0000a0">-Append -Force</font></font></strong></em></p></blockquote><br /><h3>Try It Out Yourself</h3><br /><p align="justify">You probably have a different backup strategy, but you can still take advantage of PowerShell and SyncToy in a whole host of other scenarios. <a href="https://skydrive.live.com/?cid=a0f4e46186f7cce4&amp;sc=documents&amp;id=A0F4E46186F7CCE4%211240#" target="_blank">Download the script here</a>. Tweak it till it fit your requirements and please leave a comment below if you have a question or found a bug somewhere in the script. Even if not for mirroring hard drives, this still was a nice exercise for using PowerShell. </p><br><iframe style="padding-bottom: 0px; background-color: #fcfcfc; padding-left: 0px; width: 98px; padding-right: 0px; height: 115px; padding-top: 0px" title="Preview" marginheight="0" src="https://skydrive.live.com/embedicon.aspx/Public/Blog/Mirroring%20Hard%20Drives%20using%20PowerShell%20and%20SyncToy/MirrorDrives.ps1?cid=a0f4e46186f7cce4&amp;sc=documents" frameborder="0" marginwidth="0" scrolling="no"></iframe>  
