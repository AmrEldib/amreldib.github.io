---
layout: post
name: real-time-gis-using-signalr-and-esri-s-javascript-api
title: Real-Time GIS Using SignalR and Esri's JavaScript API
time: 2013-03-28 10:43:00.001000000 -07:00
tags:
- JavaScript
- GIS
- DevSummit
- Esri
- SignalR
- Presentation
- ArcGIS
- Code
---
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-pN2PrBebQcY/UVR-EXSQZdI/AAAAAAAAAVQ/7JovU76Gcuo/s1600/SignalR.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://4.bp.blogspot.com/-pN2PrBebQcY/UVR-EXSQZdI/AAAAAAAAAVQ/7JovU76Gcuo/s200/SignalR.jpg" width="200" /></a> <a href="http://4.bp.blogspot.com/-JHt1aIka_YU/UVR-GQN1eoI/AAAAAAAAAVY/Ef9kmpMRGM4/s1600/JavascriptLogo.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="200" src="http://4.bp.blogspot.com/-JHt1aIka_YU/UVR-GQN1eoI/AAAAAAAAAVY/Ef9kmpMRGM4/s200/JavascriptLogo.png" width="200" /></a></div>Everybody loves command centers. We all would love to be Capitan Kirk, setting there seeing information coming in from all over the place, and we can act on it without having to do much work.<br /><br />The problem with building command centers is that they represent a big unnecessary load on the servers. Command centers now are not like the Star Trek command centers. No, they're hundreds of users connected to your service, each trying to command their own one decision which in aggregate with hundreds of other users form the output of the system.<br /><br />These hundreds of computers calling the server every few seconds checking if there's an update or not represent a big unnecessary load on the server. What I prefer is to call the server when I know that there's an update, or better, have the server call me, the client, when there's an update.<br /><br />That's where SignalR comes in.<br /><br /><a href="http://signalr.net/" target="_blank">SignalR</a> is an open source library that let's you build front-end real-time applications using JavaScript (or .NET). On the back-end you'll use .NET.<br /><br />SignalR was a side project started by two guys; <a href="https://twitter.com/davidfowl" target="_blank">David Fowler</a> and <a href="https://twitter.com/DamianEdwards" target="_blank">Damian Edwards</a>. The <a href="https://github.com/SignalR/SignalR" target="_blank">source code </a>is hosted on <span id="goog_1340908699"></span>GitHub<span id="goog_1340908700"></span>. The project got so much support that <a href="http://www.asp.net/signalr/open-source" target="_blank">Microsoft is now supporting</a> it as part of its ASP.NET family even while maintaining it's status as an open source project developed in the open.<br /><br /><a href="http://www.hanselminutes.com/352/making-open-source-work-at-microsoft-with-signalr-and-damian-edwards" target="_blank">Listen</a> to Damian Edwards interviewed by Scott Hanselman about SignalR.<br /><a href="http://channel9.msdn.com/Series/Building-Web-Apps-with-ASP-NET-Jump-Start/Building-Web-Apps-with-ASPNET-Jump-Start-08-Real-time-Communication-with-SignalR" target="_blank">Watch</a> Damian Edwards and Scott Hanselman demo how to use SignalR.<br /><br />SignalR makes it incredibly simple to add real-time functionality to your application.<br /><br />It’s simple because it provides you with a way to just call a function on the client-side. Just RPC a function on the client-side.<br /><br />It’s simple because it your code will work – without you having to change it – with a number of different technologies under the hood.<br /><br />It starts with WebSockets, and falls back to other technologies if it’s not available.<br /><br />There are two examples for SignalR you can check out right now: <a href="http://jabbr.net/" target="_blank">Jabbr</a> which is a chat room service. And <a href="http://shootr.signalr.net/" target="_blank">ShootR</a>; a space craft shooter game built with HTML5.<br /><br />SignalR is split into a .NET component on the server side, and a JavaScript component on the client side. Basically, you create a class that inherits from a Hub class and whatever public method you create is now callable from the client side.<br /><br />The important thing is that you can define client side functions that are also callable from the server side.<br /><br />We can use this to add real-time capability to an ArcGIS JavaScript API application. Using a <a href="http://help.arcgis.com/en/webapi/javascript/arcgis/jssamples/graphics_add.html" target="_blank">sample from the documentation</a>, I've added the real-time capability using a C# class and few modifications to the client side JavaScript.<br /><br />Here's a video for how the final proof-of-concept looks like:<br /><br /><iframe allowfullscreen="" frameborder="0" height="315" src="http://www.youtube.com/embed/kY3AQL6n2-8" width="560"></iframe> <br />The code is all up on <a href="https://github.com/AmrEldib/RealTimeGisWithSignalR" target="_blank">GitHub</a>.<br /><br />I was invited to speak at Esri DevSummit 2013 on March 28, 2013. Here are the slides for my talk. They provide few more details. <br /><iframe frameborder="0" height="400" marginheight="0" marginwidth="0" scrolling="no" src="http://www.slideshare.net/slideshow/embed_code/17814815" width="476"></iframe> <br />There's a few book on SignalR out now, you can get <a href="http://www.campusmvp.net/signalr-ebook/" target="_blank">here</a>. <br /><br />If you have any questions, please add a comment below.
